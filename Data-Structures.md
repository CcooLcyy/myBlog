---
title: Data Structures
date: 2021-09-03 22:18:48
tags:
---
# 抽象数据类型

抽象之后我们没有必要知道到底发生了什么，我们只需要知道这样做能产生什么样的结果就行。

将程序分割为不同的模块，通过调用不同的**模块**运行程序，这样做有很多好处：
1. 可以将修改限定到特定的模块中，在修改的时候可以只修改不同的模块，有利于多人同时进行程序的编写。
2. 调试小程序的时候会比调试大程序更加简单，并且可以大大减少编译的时间。
3. 不同的模块相互之间是透明的，只需要模块能实现功能就可以。
但同时在进行模块话编写的时候一定要注意全局变量的问题。
*抽象数据类型*，就是进行数学抽象，并且不暴露具体的模块实现细节。
# 线性表
一般就是一个从１到N的表，大小是N，我们称大小为０的表为空表。对于任何第一个和最后一个的任意一个元素，前一个元素称为前驱元，后一个元素为后继元。最后一个元素不定义后继元，第一个元素不定义前驱元。
ADT是一种数学的抽象，因此ADT本身并不定义任何操作，所有的操作都是根据程序员的需要来决定的。如果我们需要某种操作，我们就可以定义这个操作。
## 顺序表
顺序表的所有操作都可以使用数组来实现，不过使用数组来实现有一定的局限性：
1. 我们需要首先对表的最大值进行估计，这个过程通常会估计的大一些，但是这样就会造成空间的浪费。
2. 而且如果使用数组来实现的话，在某些操作的时候执行时间是按照如期的时间进行的，但是插入和删除的花费是非常昂贵的，比如在第一个位置插入或删除元素需要将所有的元素都前移或者后移。两种操作的时间最坏的情况是`O(N)`，平均来看仍然需要移动一半的元素。并且如果通过N次相继插入元素来创建一个表将会需要二次的时间。
综上所述，我们不要使用数组来实现表ADT。
优点是具备随机索引特性。
## 链表
如果我们的表需要频繁的插入删除操作，可以使用链式存储结构来实现。下述定义了一个链表的节点。
```c
typedef struct node{
	elemType value;
	struct node *next;
} node, *linkedList;
```
这个结构包含需要保存的值value，以及一个指向下一个节点的指针。在增删改查的时候我们可以仅仅通过改变指针的指向就可以对整个表进行操作。但是同样如果需要索引的时候由于链表节点在内存中并非连续存储，因此我们只能通过第一个节点来依次遍历直到找到我们需要的节点。也就是说我们失去了顺序表的随机索引的优点。同时，由于在顺序表中一个节点只有需要存储的元素，但在链表中还需要保存指向下一个节点的指针，存储密度会有所降低。
链表适合需要频繁修改表的情况，修改的时间复杂度为`O(1)`但是索引的复杂度会变为`O(N)`
**问题**
1. 如果需要在链表的最后插入一个元素，那么仍然需要遍历整个链表，而遍历的时间复杂度为`O(N)`，此时单链表并不比顺序表省时。
2. 由于在插入或者删除的时候仍然需要前一个节点的地址，但前一个节点的地址保存在在前一个节点中，递归可以发现，要找到插入位置需要修改前一个节点，所以要索引找到前一个节点的地址。
**设计上的问题：**
1. 如果无法在表前显性的插入一个元素。也就是没有头节点的情况，如果进行插入
2. 从表的开头删除元素会造成表的丢失。
3. 如果删除表可能会产生一个无头指针，也就是无法索引到这个指针。
**解决方法：**
上面的问题可以通过加入一个表头（header）或者哑节点（dummy node）。当然这个表头可加可不加，根据个人习惯。但是加上程序更加清晰。
```c
typedef struct node {
	int value;
	struct node *next; 
} node;
```
这样我们就定义了一个节点，包含一个值用于存储这个节点的值，与一个指针，用于指向下一个节点。

任何ADT都有一些操作，比如：
1. IsEmpty操作：判断这个表是否为空表
```C
int IsEmpty(list l) {
	return l->next == NULL;
}
```
这个函数很简单，只要判断，这个节点的`next`指针为`NULL`那么就证明这个节点后面没有节点了，也就是这个节点为最后一个节点。
2. Find操作：用来返回某个元素在这个链表中的位置。
```c
position Find(elementType value, list l) {
	p->next;
}
```
我们定义一个位置，这个位置为链表的下一个节点，当这个节点不是最后一个节点，，并且这个节点的值不为要查找的值的时候，我们获取本节点的下一个节点，并且继续上述的判断。
只要上述判断不满足的时候，也就是这个节点的值等于我们要搜索的值的时候我们就返回这个节点，这样我们就能查找到某个值在链表中的位置。
3. FindPrevious：返回要删除的表元的前驱元。
```c
postition findPrevious(elementType x, list l) {
postition p;
p = l;
while(p->next != NULL && p->next->element != x)
	p = p->next;
}
return p;
```
因为ADT的操作都是由程序员决定的，因此，我们为了更方便的删除元素，我们可以定义一个查找元素的前一个元素。
4. Insert操作：

