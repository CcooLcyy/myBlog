---
title: Data Structures
date: 2021-09-03 22:18:48
tags:
---
# 抽象数据类型
将程序分割为不同的模块，通过调用不同的**模块**运行程序，这样做有很多好处：
1. 可以将修改限定到特定的模块中，在修改的时候可以只修改不同的模块，有利于多人同时进行程序的编写。
2. 调试小程序的时候会比调试大程序更加简单，并且可以大大减少编译的时间。
3. 不同的模块相互之间是透明的，只需要模块能实现功能就可以。
但同时在进行模块话编写的时候一定要注意全局变量的问题。
*抽象数据类型*，就是进行数学抽象，并且不暴露具体的模块实现细节。
# 表ADT
一般就是一个从１到N的表，大小是N，我们称大小为０的表为空表。对于任何第一个和最后一个的任意一个元素，前一个元素称为前驱元，后一个元素为后继元。最后一个元素不定义后继元，第一个元素不定义前驱元。
ADT是一种数学的抽象，因此ADT本身并不定义任何操作，所有的操作都是根据程序员的需要来决定的。如果我们需要某种操作，我们就可以定义这个操作。
## 表的简单实现
表的所有操作都可以使用数组来实现，不过使用数组来实现有一定的局限性：
1. 我们需要首先对表的最大值进行估计，这个过程通常会估计的大一些，但是这样就会造成空间的浪费。
2. 而且如果使用数组来实现的话，在某些操作的时候执行时间是按照如期的时间进行的，但是插入和删除的花费是非常昂贵的，比如在第一个位置插入或删除元素需要将所有的元素都前移或者后移。两种操作的时间最坏的情况是`O(N)`，平均来看仍然需要移动一半的元素。并且如果通过N次相继插入元素来创建一个表将会需要二次的时间。
综上所述，我们不要使用数组来实现表ADT。
## 链表
如果我们能够创建一个不连续的表，这个表中都是由一个个节点组成（node），但是这个表通过某些条链连接的，那么我们就不需要将所有的元素进行移动，这就是链表。
我们使用一个指针来当作链，用来连接后继元，我们称之为`next`指针，最后一个指针指向`NULL`这个指针又指向下一个节点，也就是`P->FieldName`
**设计上的问题：**
1. 如果无法在表前显性的插入一个元素。
2. 从表的开头删除元素会造成表的丢失。
3. 如果删除表可能会产生一个无头指针，也就是无法索引到这个指针。
**解决方法：**
上面的问题可以通过加入一个表头（header）或者哑节点（dummy node）。当然这个表头可加可不加，根据个人习惯。但是加上程序更加清晰。
```c
typedef struct node {
	int value;
	struct node next; 
} node;
```
这样我们就定义了一个节点，包含一个值用于存储这个节点的值，与一个指针，用于指向下一个节点。

任何ADT都有一些操作，比如：
1. IsEmpty操作：判断这个表是否为空表
```C
int IsEmpty(list l) {
	return l->next == NULL;
}
```
这个函数很简单，只要判断，这个节点的`next`指针为`NULL`那么就证明这个节点后面没有节点了，也就是这个节点为最后一个节点。
2. Find操作：用来返回某个元素在这个链表中的位置。
```c
position Find(elementType value, list l) {
	p->next;
}
```
我们定义一个位置，这个位置为链表的下一个节点，当这个节点不是最后一个节点，，并且这个节点的值不为要查找的值的时候，我们获取本节点的下一个节点，并且继续上述的判断。
只要上述判断不满足的时候，也就是这个节点的值等于我们要搜索的值的时候我们就返回这个节点，这样我们就能查找到某个值在链表中的位置。
3. FindPrevious：返回要删除的表元的前驱元。
```c
postition findPrevious(elementType x, list l) {
postition p;
p = l;
while(p->next != NULL && p->next->element != x)
	p = p->next;
}
return p;
```
因为ADT的操作都是由程序员决定的，因此，我们为了更方便的删除元素，我们可以定义一个查找元素的前一个元素。
4. Insert操作：

